grammar JsonQuery
  rule expression
    additive / multiplicative / atom
  end
  
  rule query
    identifier filter* <Query>
  end
  
  rule identifier
    (root / current / symbol) <Identifier>
  end
  
  rule root
    "$" <Root>
  end
  
  rule current
    "@" <Current>
  end
  
  rule symbol
    [A-Za-z$_] [A-Za-z0-9$_]* <Symbol>
  end
  
  rule filter
    (field_access / boolean_filter) <Filter>
  end
  
  rule field_access
    ("." (symbol / all) / "[" (expression / all) "]") <FieldAccess>
  end
  
  rule all
    "*" <AllFilter>
  end
  
  rule boolean_filter
    "[?" boolean_expression "]" <BooleanFilter>
  end
  
  rule boolean_expression
    or_expression / and_expression / boolean_atom
  end
  
  rule or_expression
    first:and_expression "|" second:or_expression <Or> / and_expression
  end
  
  rule and_expression
    first:boolean_atom "&" second:and_expression <And> / boolean_atom
  end
  
  rule boolean_atom
    space ("(" boolean_expression ")" / first:expression comparator second:expression) space <BooleanAtom>
  end
  
  rule additive
    first:multiplicative operator:(add / subtract) second:additive <Additive> / multiplicative
  end
  
  rule multiplicative
    first:atom operator:(times / divide) second:multiplicative <Multiplicative> / atom
  end
  
  rule atom
    space ("(" expression ")" / query / number / string / boolean / null) space <Atom>
  end
  
  rule times
    "*" <Multiplication>
  end
  
  rule divide
    "/" <Division>
  end
  
  rule add
    "+" <Addition>
  end
  
  rule subtract
    "-" <Subtraction>
  end
  
  rule comparator
    (not_equal / lte / gte / equal / lt / gt) <Comparator>
  end
  
  rule equal
    "=" <Equal>
  end
  
  rule not_equal
    "!=" <NotEqual>
  end
  
  rule lt
    "<" <LessThan>
  end
  
  rule lte
    "<=" <LessThanOrEqual>
  end
  
  rule gt
    ">" <GreaterThan>
  end
  
  rule gte
    ">=" <GreaterThanOrEqual>
  end
  
  rule string
    "'" ('\\' ("'" / '\\' / '/' / 'b' / 'f' / 'n' / 'r' / 't' / 'u' hex hex hex hex) / [^\'\\])* "'" <String>
  end
  
  rule number
    "-"? ("0" / [1-9] digit*) ("." digit+)? ([eE] [+-]? digit+)? <Number>
  end
  
  rule digit
    [0-9]
  end
  
  rule boolean
    (true / false) <Boolean>
  end
  
  rule true
    "true" <True>
  end
  
  rule false
    "false" <False>
  end
  
  rule null
    "null" <Null>
  end
  
  rule space
    " "*
  end
end

